<!-- build time:Tue Sep 06 2022 13:28:53 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="一梦空间" href="http://leomeng86.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="一梦空间" href="http://leomeng86.github.io/atom.xml"><link rel="alternate" type="application/json" title="一梦空间" href="http://leomeng86.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="编程,数据结构"><link rel="canonical" href="http://leomeng86.github.io/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"><title>数据结构第六次上机实验 | One Dream = 一梦空间 = 路漫漫其修远兮，吾将上下而求索</title><meta name="generator" content="Hexo 6.2.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">数据结构第六次上机实验</h1><div class="meta"><span class="item" title="创建时间：2022-09-06 12:02:32"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-09-06T12:02:32+08:00">2022-09-06</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">One Dream</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipexoj0moj20zk0m8kgu.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeudstjqj20zk0m8k3r.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipexj2jgzj20zk0m8b09.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giciszlczyj20zk0m816d.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeubcbajj20zk0m8h1h.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://leomeng86.github.io/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Leo Meng"><meta itemprop="description" content="路漫漫其修远兮，吾将上下而求索, 欢迎来带一梦空间"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一梦空间"></span><div class="body md" itemprop="articleBody"><h2 id="第一题稀疏矩阵之差"><a class="anchor" href="#第一题稀疏矩阵之差">#</a> <strong>第一题：稀疏矩阵之差</strong></h2><p>矩阵 A 和 B 都是稀疏矩阵。请计算矩阵的差 A-B. 如果 A、B 不能计算差值，输出”Illegal!”</p><h3 id="输入格式"><a class="anchor" href="#输入格式">#</a> <strong>输入格式</strong></h3><p>矩阵的输入采用三元组表示，先 A 后 B。对每个矩阵：</p><p>第 1 行，3 个整数 N、M、t，用空格分隔，分别表示矩阵的行数、列数和非 0 数据项数，10≤N、M≤50000，t≤min (N,M).</p><p>第 2 至 t+1 行，每行 3 个整数 r、c、v，用空格分隔，表示矩阵 r 行 c 列的位置是非 0 数据项 v, v 在 32 位有符号整型范围内。三元组默认按行列排序。</p><h3 id="输出格式"><a class="anchor" href="#输出格式">#</a> <strong>输出格式</strong></h3><p>矩阵 A-B，采用三元组表示，默认按行列排序，非零项也在 32 位有符号整型范围内。</p><h3 id="输入样例"><a class="anchor" href="#输入样例">#</a> <strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p><p><strong>in</strong></p><pre><code>10 10 3
2 2 2
5 5 5
10 10 20
10 10 2
2 2 1
6 6 6
</code></pre><h3 id="输出样例"><a class="anchor" href="#输出样例">#</a> <strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p><p><strong>out</strong></p><pre><code>10 10 4
2 2 1
5 5 5
6 6 -6
10 10 20
</code></pre><h3 id="题目解析"><a class="anchor" href="#题目解析">#</a> <strong>题目解析</strong></h3><h3 id="方法一归并"><a class="anchor" href="#方法一归并">#</a> <strong>方法一：归并</strong></h3><p>注意到题目给出的三元组已经按照行列排序，且输出要求也要求按照行列顺序，这里使用一个归并的方法，如果第一个矩阵的三元组小于第二个的，直接储存第一个，如果相等，输出相减后储存，如果第二个矩阵的三元组位置较小，储存第二个矩阵的相反数。</p><p>里面有一个坑，相减后可能出现 0 的情况，一旦出现结果零，即不储存。</p><p><strong>cpp</strong></p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;
int main()
&#123;
    int CNT;
    vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; a, b, c;
    int n, m, cnt;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; cnt;
    CNT = cnt;
    while (cnt--)
    &#123;
        int tn, tm, val;
        cin &gt;&gt; tn &gt;&gt; tm &gt;&gt; val;
        auto tmp = pair&lt;int, int&gt;(tn, tm);
        a.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, val));
    &#125;
    int n2, m2, cnt2;
    cin &gt;&gt; n2 &gt;&gt; m2 &gt;&gt; cnt2;
    CNT += cnt2;
    if (n2 != n || m != m2)
    &#123;
        cout &lt;&lt; &quot;Illegal!&quot;;
        return 0;
    &#125;
    while (cnt2--)
    &#123;
        int tn, tm, val;
        cin &gt;&gt; tn &gt;&gt; tm &gt;&gt; val;
        auto tmp = pair&lt;int, int&gt;(tn, tm);
        b.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, val));
    &#125;
    auto t1 = a.begin();
    auto t2 = b.begin();
    while (t1 != a.end() &amp;&amp; t2 != b.end())
    &#123;
        if (t1-&gt;first.first == t2-&gt;first.first)
        &#123;
            if (t2-&gt;first.second == t1-&gt;first.second)
            &#123;
                auto tmp = pair&lt;int, int&gt;(t1-&gt;first.first, t1-&gt;first.second);
                if (t1-&gt;second - t2-&gt;second != 0)
                    c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, t1-&gt;second - t2-&gt;second));
                else
                &#123;
                    CNT--;
                &#125;
                t1++, t2++;
                CNT--;
            &#125;
            else if (t1-&gt;first.second &lt; t2-&gt;first.second)
            &#123;
                auto tmp = pair&lt;int, int&gt;(t1-&gt;first.first, t1-&gt;first.second);
                c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, t1-&gt;second));
                t1++;
            &#125;
            else if (t1-&gt;first.second &gt; t2-&gt;first.second)
            &#123;
                auto tmp = pair&lt;int, int&gt;(t2-&gt;first.first, t2-&gt;first.second);
                c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, -t2-&gt;second));
                t2++;
            &#125;
        &#125;
        else if (t1-&gt;first.first &lt; t2-&gt;first.first)
        &#123;
            auto tmp = pair&lt;int, int&gt;(t1-&gt;first.first, t1-&gt;first.second);
            c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, t1-&gt;second));
            t1++;
        &#125;
        else if (t1-&gt;first.first &gt; t2-&gt;first.first)
        &#123;
            auto tmp = pair&lt;int, int&gt;(t2-&gt;first.first, t2-&gt;first.second);
            c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, -t2-&gt;second));
            t2++;
        &#125;
    &#125;
    while (t2 != b.end())
    &#123;
        auto tmp = pair&lt;int, int&gt;(t2-&gt;first.first, t2-&gt;first.second);
        c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, -t2-&gt;second));
        t2++;
    &#125;
    while (t1 != a.end())
    &#123;
        auto tmp = pair&lt;int, int&gt;(t1-&gt;first.first, t1-&gt;first.second);
        c.push_back(pair&lt;pair&lt;int, int&gt;, int&gt;(tmp, t1-&gt;second));
        t1++;
    &#125;
    auto it = c.begin();
    cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; CNT &lt;&lt; &quot;\n&quot;;
    while (it != c.end())
    &#123;
        cout &lt;&lt; it-&gt;first.first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;first.second &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second;
        if (it + 1 != c.end())
            cout &lt;&lt; &quot;\n&quot;;
        it++;
    &#125;
    return 0;
&#125;
</code></pre><h2 id="第二题二叉树的最短路径长"><a class="anchor" href="#第二题二叉树的最短路径长">#</a> <strong>第二题：二叉树的最短路径长</strong></h2><p>给定一棵二叉树 T，每个结点赋一个权值。计算从根结点到所有结点的最短路径长度。路径长度定义为：路径上的每个顶点的权值和。</p><h3 id="输入格式-2"><a class="anchor" href="#输入格式-2">#</a> <strong>输入格式</strong></h3><p>第 1 行，1 个整数 n，表示二叉树 T 的结点数，结点编号 1..n，1≤n≤20000。</p><p>第 2 行，n 个整数，空格分隔，表示 T 的先根序列，序列中结点用编号表示。</p><p>第 3 行，n 个整数，空格分隔，表示 T 的中根序列，序列中结点用编号表示。</p><p>第 4 行，n 个整数 Wi，空格分隔，表示 T 中结点的权值，-10000≤Wi≤10000，1≤i≤n。</p><h3 id="输出格式-2"><a class="anchor" href="#输出格式-2">#</a> <strong>输出格式</strong></h3><p>1 行，n 个整数，表示根结点到其它所有结点的最短路径长度。</p><h3 id="输入样例-2"><a class="anchor" href="#输入样例-2">#</a> <strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p><p><strong>in</strong></p><pre><code>4
1 2 4 3
4 2 1 3
1 -1 2 3
</code></pre><h3 id="输出样例-2"><a class="anchor" href="#输出样例-2">#</a> <strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p><p><strong>out</strong></p><pre><code>1 0 3 3
</code></pre><h3 id="题目解析-2"><a class="anchor" href="#题目解析-2">#</a> <strong>题目解析</strong></h3><p>使用中根序列和先跟序列递归建树，然后 DFS 更新每个节点的最短路径长度。</p><p><strong>cpp</strong></p><pre><code>#include &lt;iostream&gt;using namespace std;

int _val[20001];
int result[20001] = &#123;0&#125;;

struct node
&#123;
    int val;
    node *left;
    node *right;
&#125;;

node *build(int *pre, int *in, int size)
&#123;
    if (size &lt;= 0)
        return nullptr;

    int i;
    for (i = 0; i &lt;= size - 1; i++)
    &#123;
        if (in[i] == pre[0])
            break;
    &#125;

    node *tree = new node;
    tree-&gt;val = pre[0];
    tree-&gt;left = build(pre + 1, in, i);
    tree-&gt;right = build(pre + i + 1, in + i + 1, size - 1 - i);
    return tree;
&#125;

void DFS(node * root, int cost)
&#123;
    if(root == nullptr) return;
    result[root-&gt;val] = cost + _val[root-&gt;val];
    DFS(root-&gt;left, result[root-&gt;val]);
    DFS(root-&gt;right, result[root-&gt;val]);
&#125;

int main()
&#123;
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    int _pre[20001], _in[20001];

    for(int i = 0; i &lt;= n - 1; i++)
    &#123;
        scanf(&quot;%d&quot;, &amp;_pre[i]);
    &#125;

    for(int i = 0; i &lt;= n - 1; i++)
    &#123;
        scanf(&quot;%d&quot;, &amp;_in[i]);
    &#125;

    for(int i = 1; i &lt;= n; i++)
    &#123;
        scanf(&quot;%d&quot;, &amp;_val[i]);
    &#125;

    node* root = build(_pre,_in,n);

    DFS(root, 0);

    for(int i = 1; i &lt;= n; i++)
    &#123;
        printf(&quot;%d&quot;, result[i]);
        if(i != n) printf(&quot; &quot;);
    &#125;
    printf(&quot;\n&quot;);
&#125;
</code></pre><h3 id="第三题文字编辑"><a class="anchor" href="#第三题文字编辑">#</a> <strong>第三题：文字编辑</strong></h3><p>一篇文章由 n 个汉字构成，汉字从前到后依次编号为 1，2，……，n。有四种操作：</p><p>A i j 表示把编号为 i 的汉字移动编号为 j 的汉字之前；</p><p>B i j 表示把编号为 i 的汉字移动编号为 j 的汉字之后；</p><p>Q 0 i 为询问编号为 i 的汉字之前的汉字的编号；</p><p>Q 1 i 为询问编号为 i 的汉字之后的汉字的编号。</p><p>规定：1 号汉字之前是 n 号汉字，n 号汉字之后是 1 号汉字。</p><h3 id="输入格式-3"><a class="anchor" href="#输入格式-3">#</a> <strong>输入格式</strong></h3><p>第 1 行，1 个整数 T，表示有 T 组测试数据， 1≤T≤9999.</p><p>随后的每一组测试数据中，第 1 行两个整数 n 和 m，用空格分隔，分别代表汉字数和操作数，2≤n≤9999，1≤m≤9999；第 2 至 m+1 行，每行包含 3 个常量 s、i 和 j，用空格分隔，s 代表操作的类型，若 s 为 A 或 B，则 i 和 j 表示汉字的编号，若 s 为 Q，i 代表 0 或 1，j 代表汉字的编号。</p><h3 id="输出格式-3"><a class="anchor" href="#输出格式-3">#</a> <strong>输出格式</strong></h3><p>若干行，每行 1 个整数，对应每个询问的结果汉字编号。</p><h3 id="输入样例-3"><a class="anchor" href="#输入样例-3">#</a> <strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p><p><strong>in</strong></p><pre><code>1
9999 4
B 1 2
A 3 9999
Q 1 1
Q 0 3
</code></pre><h3 id="输出样例-3"><a class="anchor" href="#输出样例-3">#</a> <strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p><p><strong>out</strong></p><pre><code>4
9998
</code></pre><h3 id="题目解析-3"><a class="anchor" href="#题目解析-3">#</a> <strong>题目解析</strong></h3><h3 id="方法一跳舞链"><a class="anchor" href="#方法一跳舞链">#</a> <strong>方法一：跳舞链</strong></h3><p>实现定点插入，定点查询，定点删除，且能满足 1000ms 的时间限制，使用跳舞链会比较合适。</p><p>本题使用静态链表实现，会比较好写。</p><p><strong>cpp</strong></p><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;
int main()
&#123;
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    int pre[100001];
    int nxt[100001];
    int n, m;
    for (register int j = 0; j &lt;= T - 1; j++)
    &#123;
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for (register int i = 1; i &lt;= n; i++)
        &#123;

            pre[i] = i - 1;
            nxt[i] = i + 1;
        &#125;
        pre[1] = n;
        nxt[n] = 1;
        for (register int k = 0; k &lt;= m - 1; k++)
        &#123;
            char ch;
            int op1, op2;
            cin &gt;&gt; ch;
            scanf(&quot;%d%d&quot;, &amp;op1, &amp;op2);
            switch (ch)
            &#123;
            case 'A':
            &#123;
                nxt[pre[op1]] = nxt[op1];
                pre[nxt[op1]] = pre[op1];
                pre[op1] = pre[op2];
                nxt[op1] = op2;
                nxt[pre[op2]] = op1;
                pre[op2] = op1;
                break;
            &#125;
            case 'B':
            &#123;
                nxt[pre[op1]] = nxt[op1];
                pre[nxt[op1]] = pre[op1];
                pre[op1] = op2;
                nxt[op1] = nxt[op2];
                pre[nxt[op2]] = op1;
                nxt[op2] = op1;
                break;
            &#125;
            case 'Q':
            &#123;
                switch (op1)
                &#123;
                case 0:
                &#123;
                    printf(&quot;%d\n&quot;, pre[op2]);
                    break;
                &#125;
                case 1:
                &#123;
                    printf(&quot;%d\n&quot;, nxt[op2]);
                    break;
                &#125;
                &#125;
                break;
            &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><h3 id="第四题方案计数"><a class="anchor" href="#第四题方案计数">#</a> <strong>第四题：方案计数</strong></h3><p>组装一个产品需要 n 个零件。生产每个零件都需花费一定的时间。零件的生产可以并行进行。有些零件的生产有先后关系，只有一个零件的之前的所有零件都生产完毕，才能开始生产这个零件。如何合理安排工序，才能在最少的时间内完成所有零件的生产。在保证最少时间情况下，关键方案有多少种，关键方案是指从生产开始时间到结束时间的一个零件生产序列，序列中相邻两个零件的关系属于事先给出的零件间先后关系的集合，序列中的每一个零件的生产都不能延期。</p><h3 id="输入格式-4"><a class="anchor" href="#输入格式-4">#</a> <strong>输入格式</strong></h3><p>第 1 行，2 个整数 n 和 m，用空格分隔，分别表示零件数和关系数，零件编号 1..n，1≤n≤10000, 0≤m≤100000 。</p><p>第 2 行，n 个整数 Ti，用空格分隔，表示零件 i 的生产时间，1≤i≤n，1≤Ti≤100 。</p><p>第 3 到 m+2 行，每行两个整数 i 和 j，用空格分隔，表示零件 i 要在零件 j 之前生产。</p><h3 id="输出格式-4"><a class="anchor" href="#输出格式-4">#</a> <strong>输出格式</strong></h3><p>第 1 行，1 个整数，完成生产的最少时间。</p><p>第 2 行，1 个整数，关键方案数，最多 100 位。</p><p>如果生产不能完成，只输出 1 行，包含 1 个整数 0.</p><h3 id="输入样例-4"><a class="anchor" href="#输入样例-4">#</a> <strong>输入样例</strong></h3><p>在这里给出一组输入。例如：</p><p><strong>in</strong></p><pre><code>4 4
1 2 2 1
1 2
1 3
2 4
3 4
</code></pre><h3 id="输出样例-4"><a class="anchor" href="#输出样例-4">#</a> <strong>输出样例</strong></h3><p>在这里给出相应的输出。例如：</p><p><strong>out</strong></p><pre><code>4
2
</code></pre><h3 id="题目解析-4"><a class="anchor" href="#题目解析-4">#</a> <strong>题目解析</strong></h3><h3 id="方法一拓扑排序关键路径高精度"><a class="anchor" href="#方法一拓扑排序关键路径高精度">#</a> <strong>方法一：拓扑排序 + 关键路径 + 高精度</strong></h3><p>感谢 mxgg，上次有一个题目一直段错误，mxgg 发现是我爆了 int，建议我以后 #define int long long, 我说以后不是 BigInteger 我都不用，然后就机缘巧合向大佬学习写了 BigInt 的板子，mxgg yyds！！！</p><p>除了需要高精度，读图时候，需要点权推到边权上，并把入度为 0 的点引到虚源，出度为 0 的点汇到虚源上，形成连通图，然后拓扑排序和关键路径算法。</p><p>对于我这种蒟蒻，存板子就是我白月光！！！膜拜手拍大佬！！！</p><p><strong>cpp</strong></p><pre><code>#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;limits&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;

class Bigint
&#123;
private:
    vector&lt;int&gt; content;
public:
    Bigint();
    Bigint(long long origin);
    Bigint(const Bigint&amp; b);
    ~Bigint();
    unsigned long long size() const;
    Bigint operator+(const Bigint&amp; b);
    Bigint&amp; operator=(const Bigint&amp; b);
    void resize(unsigned long long n);
    const int&amp; operator[](unsigned long long i)const;
    int&amp; operator[](unsigned long long i);
    string toString();
&#125;;

Bigint::Bigint()&#123;
    content.reserve(128);
    for (int i = 0; i &lt; 128; ++i)&#123;
        content.push_back(0);
    &#125;

&#125;

Bigint::Bigint(long long origin)&#123;
    content.reserve(128);
    while (origin&gt;0)
    &#123;
        content.push_back(origin%10);
        origin=origin/10;
    &#125;
&#125;
Bigint::Bigint(const Bigint&amp; b)&#123;
    content.clear();
    for(int i=0;i&lt;b.size();++i)&#123;
        content.push_back(b[i]);
    &#125;
&#125;

Bigint::~Bigint()&#123;
    content.clear();
&#125;

Bigint Bigint::operator+(const Bigint&amp; b)&#123;
    Bigint t;
    Bigint res;
    unsigned long long maxsize=max(this-&gt;size(),b.size());
    t.resize(maxsize+1);
    res.resize(maxsize+1);
    for (int i = 0; i &lt; maxsize; ++i)&#123;
        int num1=i&lt;this-&gt;size()?content[i]:0;
        int num2=i&lt;b.size()?b[i]:0;
        res[i]=(num1+num2+t[i])%10;
        t[i+1]=(num1+num2+t[i])/10;
    &#125;
    if(t[maxsize]!=0)&#123;
        res[maxsize]=t[maxsize];
    &#125;else&#123;
        res.resize(maxsize);
    &#125;
    return res;
&#125;

Bigint&amp; Bigint::operator=(const Bigint&amp; b)&#123;
    if(this==&amp;b)&#123;
        return *this;
    &#125;else&#123;
        content.clear();
        content.reserve(b.size());
        for(int i=0;i&lt;b.size();++i)&#123;
            content.push_back(b[i]);
        &#125;
    &#125;
    return *this;
&#125;

unsigned long long Bigint::size()const&#123;
        return content.size();
&#125;

const int&amp; Bigint::operator[](unsigned long long i)const&#123;
    if(i&gt;content.size())return *content.end();
    return (*(content.begin()+i));
&#125;

int&amp; Bigint::operator[](unsigned long long i)&#123;
    if(i&gt;content.size())return *content.end();
    return (*(content.begin()+i));
&#125;

void Bigint::resize(unsigned long long n)&#123;
    if(n&gt;this-&gt;size())&#123;
        for (unsigned long long i = this-&gt;size(); i &lt;n; ++i)&#123;
            content.push_back(0);
        &#125;
    &#125;else&#123;
        for (unsigned long long i = this-&gt;size(); i&gt;n; --i)&#123;
            content.pop_back();
        &#125;
    &#125;
&#125;

string Bigint::toString()&#123;
    bool flag=true;
    string res;
    for (int i = this-&gt;size()-1; i &gt;=0; --i)&#123;
        if(flag&amp;&amp;content[i]==0)&#123;
            continue;
        &#125;else&#123;
            if(flag&amp;&amp;content[i]!=0)&#123;
                flag=false;
            &#125;
            res.push_back(content[i]+48);
        &#125;
    &#125;
    if(flag)res.push_back('0');
    return res;
&#125;

const int maxn = 10010;
int n = 0, m = 0;

int inDu[maxn] = &#123;0&#125;;
int inDu_bfs[maxn] = &#123;0&#125;;
int outDu[maxn] = &#123;0&#125;;
int es[maxn] = &#123;0&#125;;
int ls[maxn];
int cs[maxn] = &#123;0&#125;;

struct Node
&#123;
    Node* nxt;
    int val;
    int cost;
    Node(int _val = 0, int _cost = 0)
    &#123;
        cost = _cost;
        val = _val;
        nxt = nullptr;
    &#125;
&#125;;

Node *phead[maxn] = &#123;nullptr&#125;, *ptail[maxn] = &#123;nullptr&#125;;

void add(int _fr, int _to, int _cost)
&#123;
    Node *t = ptail[_fr];
    if (t == nullptr)
    &#123;
        phead[_fr] = new Node(_to,_cost);
        ptail[_fr] = phead[_fr];
    &#125;
    else
    &#123;
        ptail[_fr]-&gt;nxt = new Node(_to, _cost);
        ptail[_fr] = ptail[_fr]-&gt;nxt;
    &#125;
    outDu[_fr]++;
    inDu[_to]++;
    inDu_bfs[_to]++;

&#125;

void read_map()
&#123;
    for(int i = 1; i &lt;= n ; i++)
    &#123;
        scanf(&quot;%d&quot;, &amp;cs[i]);
    &#125;
    int _fr = 0, _to = 0;
    for(int i  = 0; i &lt;= m - 1; i++)
    &#123;
        scanf(&quot;%d%d&quot;, &amp;_fr, &amp;_to);
        add(_fr, _to, cs[_to]);
    &#125;

    for(int i = 1; i &lt;= n; i++)
    &#123;
        if(inDu[i] == 0)
        &#123;
            add(0,i,cs[i]);
        &#125;
        if(outDu[i] == 0)
        &#123;
            add(i, n + 1, 0);
        &#125;
    &#125;
&#125;

vector&lt;int&gt; topo_result;
void topo()
&#123;
    queue&lt;int&gt; q;
    topo_result.reserve(maxn);
    q.push(0);
    while(!q.empty())
    &#123;
        int now = q.front();
        q.pop();
        topo_result.push_back(now);
        for(auto it = phead[now]; it!= nullptr; it= it-&gt;nxt)
        &#123;
            int to = it-&gt;val;
            int cost = it-&gt;cost;
            inDu[to]--;
            if(inDu[to] == 0)
            &#123;
                q.push(to);
            &#125;
            es[to] = max(es[now] + cost, es[to]);
        &#125;
    &#125;
&#125;

void Cpath()
&#123;
    topo();
    ls[n+1] = es[n+1];
    for(int i = topo_result.size() - 1; i &gt;= 0; i--)
    &#123;
        int now = topo_result[i];
        for(auto it = phead[now]; it != nullptr; it = it-&gt;nxt)
        &#123;
            int to = it-&gt;val;
            int cost = it-&gt;cost;
            ls[now] = min(ls[to]-cost, ls[now]);
        &#125;
    &#125;
&#125;

Bigint tmp[maxn];
Bigint res;
int vis[maxn] = &#123;0&#125;;

void bfs(int x)
&#123;
    queue&lt;int&gt; q;
    q.push(x);
    vis[x] = 1;
    while(!q.empty())
    &#123;
        int now = q.front();
        q.pop();
        vis[now] = 1;
        for(auto it = phead[now]; it != nullptr; it = it-&gt;nxt)
        &#123;
            int to = it-&gt;val;
            inDu_bfs[to]--;
            if(es[to] == ls[to])
            &#123;
                tmp[to] = tmp[now] + tmp[to];
            &#125;
            if(inDu_bfs[to] == 0)
            &#123;
                q.push(to);
            &#125;
        &#125;
    &#125;
&#125;

int main()
&#123;
    for(int i = 0; i &lt;= maxn - 1; i++)
    &#123;
        ls[i] = INT32_MAX;
    &#125;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    read_map();
    Cpath();
    tmp[0] = 1;
    bfs(0);
    long long result = es[n+1];
    res = tmp[n+1];
    if(res.toString() != &quot;0&quot;) cout &lt;&lt; result &lt;&lt;endl;
    cout &lt;&lt; res.toString() &lt;&lt; endl;
    return 0;
&#125;
</code></pre><div class="tags"><a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"><i class="ic i-tag"></i> 编程</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="ic i-tag"></i> 数据结构</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-09-06 13:26:06" itemprop="dateModified" datetime="2022-09-06T13:26:06+08:00">2022-09-06</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Leo Meng 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Leo Meng 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Leo Meng 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>Leo Meng： </strong>Leo Meng <i class="ic i-at"><em>@</em></i>一梦空间</li><li class="link"><strong>本文链接：</strong> <a href="http://leomeng86.github.io/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/" title="数据结构第六次上机实验">http://leomeng86.github.io/2022/09/06/数据结构第六次上机实验/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipex2cdtbj20zk0m8x6p.jpg" title="数据结构第五次上机实验"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>数据结构第五次上机实验</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%A2%98%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%B9%8B%E5%B7%AE"><span class="toc-number">1.</span> <span class="toc-text">第一题：稀疏矩阵之差</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">输入样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B"><span class="toc-number">1.4.</span> <span class="toc-text">输出样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%BD%92%E5%B9%B6"><span class="toc-number">1.6.</span> <span class="toc-text">方法一：归并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%A2%98%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%95%BF"><span class="toc-number">2.</span> <span class="toc-text">第二题：二叉树的最短路径长</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">2.1.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">2.2.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-2"><span class="toc-number">2.3.</span> <span class="toc-text">输入样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-2"><span class="toc-number">2.4.</span> <span class="toc-text">输出样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-2"><span class="toc-number">2.5.</span> <span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%A2%98%E6%96%87%E5%AD%97%E7%BC%96%E8%BE%91"><span class="toc-number">2.6.</span> <span class="toc-text">第三题：文字编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-3"><span class="toc-number">2.7.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-3"><span class="toc-number">2.8.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-3"><span class="toc-number">2.9.</span> <span class="toc-text">输入样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-3"><span class="toc-number">2.10.</span> <span class="toc-text">输出样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-3"><span class="toc-number">2.11.</span> <span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E8%B7%B3%E8%88%9E%E9%93%BE"><span class="toc-number">2.12.</span> <span class="toc-text">方法一：跳舞链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%A2%98%E6%96%B9%E6%A1%88%E8%AE%A1%E6%95%B0"><span class="toc-number">2.13.</span> <span class="toc-text">第四题：方案计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-4"><span class="toc-number">2.14.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-4"><span class="toc-number">2.15.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%B7%E4%BE%8B-4"><span class="toc-number">2.16.</span> <span class="toc-text">输入样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-4"><span class="toc-number">2.17.</span> <span class="toc-text">输出样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90-4"><span class="toc-number">2.18.</span> <span class="toc-text">题目解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">2.19.</span> <span class="toc-text">方法一：拓扑排序 + 关键路径 + 高精度</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Leo Meng" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Leo Meng</p><div class="description" itemprop="description">欢迎来带一梦空间</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">5</span> <span class="name">文章</span></a></div><div class="item tags"><a href="/tags/"><span class="count">3</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xlb21lbmc4Ng==" title="https:&#x2F;&#x2F;github.com&#x2F;leomeng86"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/" title="数据结构第五次上机实验">数据结构第五次上机实验</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/09/06/C&C++/CPP%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/" title="CPP第一次上机实验">CPP第一次上机实验</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/" title="数据结构第六次上机实验">数据结构第六次上机实验</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/" title="数据结构第三次上机实验">数据结构第三次上机实验</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2022/09/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/" title="数据结构第四次上机实验">数据结构第四次上机实验</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Leo Meng @ One Dream</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2022/09/06/数据结构第六次上机实验/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->